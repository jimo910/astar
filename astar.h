
#include"mapping.cpp"

using namespace std;
 template<class T>
 class nodes{
public:
	nodes() {
		 next = 0;
		 }
 	nodes(T el, nodes *ptr = 0) {
 		info = el; next = ptr;
 	}
 	T info;
		nodes *next;
 };


template <class T>
class queue{
public:

 queue() {
 	head = tail = 0;
 	count = 0;
   }


 bool empty() {
 return head == 0;
 }

void push( T el) {
 if (tail != 0) { // if list not empty;
 tail->next = new  nodes<T>(el);
 tail = tail->next;
 }
 else head = tail = new nodes<T>(el);
count =count +1;
}

int length(){
	return count;
}
 void pop() {
 //T el = head->info; 
 nodes<T> *tmp = head;
 if (head == tail){ // if only one node in the list;
 	head = tail = 0;}
 else {
 head = head->next;
 }
 delete tmp;
 count = count-1;
}


 T index(int j){
 	size_t i;
 	nodes<T>* start = head;
 	for(i=0; i<this->length(); i++){
 		if(j==i){
 			return start->info;
 			
		 }
		 start= start->next;
	 }
 }

T front(){
	return head->info;
}


 bool isInList(T) const;

private:
	nodes<T> *head, *tail;
	int count;
};




class astar{
	public:
		void populate(); 
		float distance( int xpar, int ypar, int xpos, int ypos); // to calculate the distance between two nodes.
		vectorBox<node* > astarAlgorithm(int sX, int sY, int tX, int tY); // the function that performs the A* agorithm.
		vectorBox <node* > drawPath(int sX, int sY, int tX, int Ty);
		void pusher( int sX, int sY); // for node localization and getting the status of the neighbouring node.
		void pushNode(node* parent ,  node* pos);  // it comaprethe current node and the neigbouring node location.
		void print_node(vectorBox <node*> hss);
		void print_node (vectorBox <char > hmm);
		void printVectorBox( vectorBox<node*> rasp);
		void asmapping(); // is used to generate  a path between a landmarks and all other landmarks.
		void changeParentNode(); // it is used to change the node being considered by the A* algo
		vectorBox<node*>  pathPlanner(int sX, int sY, int tx, int tY); //to generate path from a landmarks  to another point on the field and vice  versa
		queue < node* > shortestinQueue; // a queue containing nodes that have not been processed.
		vectorBox<node* > landmark; // container(vectorBox) containing all the landmarks's node.
		queue <node * >landmarkPointer;
		queue<node* > entered; // for processing the landmarks.
		
 private:
	friend class motionPlanner; // to allow motionPlanner class access to private attributes of the class (e.g : field and landmarks).
	 vectorBox< vectorBox<node*> > field; // a 2-dimensional custom container of all the nodes on the field.
	 vectorBox< vectorBox<node*> > controlField;
 	  vectorBox <vectorBox< vectorBox<node*> > > landmarks;
 	 node* targeted; // indicates the target node.
	 node* starter; // indicate the starting node.
	 int success; // it indicate  1 (when target node s reached), and 0 if the target node cannot be reached.
	 int mappingCount; // it indicate the node which has been processed.

};




class motionPlanner{
	
	public:

	 motionPlanner(vectorBox<node*> path, astar &get); 

		 vectorBox< char > get_vector(){
		 	 return motions;
		 }
		 
		  // get the  char vector 
		// vectorBox<node *> changed_nodes();
		 void set_vector(vectorBox <node *> s);
		 int planMotion();
		 void control_failed_plan();
		
	private:
		vectorBox <node *> path;  //the path generated by the path planning algorithm.
		vectorBox<node *> changedNode;
		vectorBox <char> motions;
		bool isplanned;
		bool isastar=true;
		int checkers; // checkers is 0(x-coordinate of current node is equal to x-cooridante of the next node) and it 1 if (the y-coordinates are equal).
		int increment;// increment  is 1( if the other unequal coordinate in of the current nad next node is increasing), 0 (if it decreasing).
		node* target;
		node* Failednode;
		vectorBox < node *> newPath;
		astar objAstar; // astar object containing the path planned.
};
